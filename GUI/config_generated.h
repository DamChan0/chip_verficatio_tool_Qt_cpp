// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_CONFIG_CHIPVERIF_H_
#define FLATBUFFERS_GENERATED_CONFIG_CHIPVERIF_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 24 &&
              FLATBUFFERS_VERSION_MINOR == 3 &&
              FLATBUFFERS_VERSION_REVISION == 25,
             "Non-compatible flatbuffers version included");

namespace ChipVerif {

struct commonRegisterInfo;
struct commonRegisterInfoBuilder;

struct registerInfo;
struct registerInfoBuilder;

struct chipTestConfig;
struct chipTestConfigBuilder;

struct commonRegisterInfo FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef commonRegisterInfoBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_FIELDNAME = 4,
    VT_ADDRESS = 6,
    VT_VALUE = 8,
    VT_FIXEDPOINT = 10
  };
  const ::flatbuffers::String *fieldName() const {
    return GetPointer<const ::flatbuffers::String *>(VT_FIELDNAME);
  }
  uint64_t address() const {
    return GetField<uint64_t>(VT_ADDRESS, 0);
  }
  float value() const {
    return GetField<float>(VT_VALUE, 0.0f);
  }
  bool fixedPoint() const {
    return GetField<uint8_t>(VT_FIXEDPOINT, 0) != 0;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_FIELDNAME) &&
           verifier.VerifyString(fieldName()) &&
           VerifyField<uint64_t>(verifier, VT_ADDRESS, 8) &&
           VerifyField<float>(verifier, VT_VALUE, 4) &&
           VerifyField<uint8_t>(verifier, VT_FIXEDPOINT, 1) &&
           verifier.EndTable();
  }
};

struct commonRegisterInfoBuilder {
  typedef commonRegisterInfo Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_fieldName(::flatbuffers::Offset<::flatbuffers::String> fieldName) {
    fbb_.AddOffset(commonRegisterInfo::VT_FIELDNAME, fieldName);
  }
  void add_address(uint64_t address) {
    fbb_.AddElement<uint64_t>(commonRegisterInfo::VT_ADDRESS, address, 0);
  }
  void add_value(float value) {
    fbb_.AddElement<float>(commonRegisterInfo::VT_VALUE, value, 0.0f);
  }
  void add_fixedPoint(bool fixedPoint) {
    fbb_.AddElement<uint8_t>(commonRegisterInfo::VT_FIXEDPOINT, static_cast<uint8_t>(fixedPoint), 0);
  }
  explicit commonRegisterInfoBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<commonRegisterInfo> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<commonRegisterInfo>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<commonRegisterInfo> CreatecommonRegisterInfo(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> fieldName = 0,
    uint64_t address = 0,
    float value = 0.0f,
    bool fixedPoint = false) {
  commonRegisterInfoBuilder builder_(_fbb);
  builder_.add_address(address);
  builder_.add_value(value);
  builder_.add_fieldName(fieldName);
  builder_.add_fixedPoint(fixedPoint);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<commonRegisterInfo> CreatecommonRegisterInfoDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *fieldName = nullptr,
    uint64_t address = 0,
    float value = 0.0f,
    bool fixedPoint = false) {
  auto fieldName__ = fieldName ? _fbb.CreateString(fieldName) : 0;
  return ChipVerif::CreatecommonRegisterInfo(
      _fbb,
      fieldName__,
      address,
      value,
      fixedPoint);
}

struct registerInfo FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef registerInfoBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_FIELDNAME = 4,
    VT_ADDRESS = 6,
    VT_VALUE = 8,
    VT_FIXEDPOINT = 10
  };
  const ::flatbuffers::String *fieldName() const {
    return GetPointer<const ::flatbuffers::String *>(VT_FIELDNAME);
  }
  uint64_t address() const {
    return GetField<uint64_t>(VT_ADDRESS, 0);
  }
  float value() const {
    return GetField<float>(VT_VALUE, 0.0f);
  }
  bool fixedPoint() const {
    return GetField<uint8_t>(VT_FIXEDPOINT, 0) != 0;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_FIELDNAME) &&
           verifier.VerifyString(fieldName()) &&
           VerifyField<uint64_t>(verifier, VT_ADDRESS, 8) &&
           VerifyField<float>(verifier, VT_VALUE, 4) &&
           VerifyField<uint8_t>(verifier, VT_FIXEDPOINT, 1) &&
           verifier.EndTable();
  }
};

struct registerInfoBuilder {
  typedef registerInfo Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_fieldName(::flatbuffers::Offset<::flatbuffers::String> fieldName) {
    fbb_.AddOffset(registerInfo::VT_FIELDNAME, fieldName);
  }
  void add_address(uint64_t address) {
    fbb_.AddElement<uint64_t>(registerInfo::VT_ADDRESS, address, 0);
  }
  void add_value(float value) {
    fbb_.AddElement<float>(registerInfo::VT_VALUE, value, 0.0f);
  }
  void add_fixedPoint(bool fixedPoint) {
    fbb_.AddElement<uint8_t>(registerInfo::VT_FIXEDPOINT, static_cast<uint8_t>(fixedPoint), 0);
  }
  explicit registerInfoBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<registerInfo> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<registerInfo>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<registerInfo> CreateregisterInfo(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> fieldName = 0,
    uint64_t address = 0,
    float value = 0.0f,
    bool fixedPoint = false) {
  registerInfoBuilder builder_(_fbb);
  builder_.add_address(address);
  builder_.add_value(value);
  builder_.add_fieldName(fieldName);
  builder_.add_fixedPoint(fixedPoint);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<registerInfo> CreateregisterInfoDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *fieldName = nullptr,
    uint64_t address = 0,
    float value = 0.0f,
    bool fixedPoint = false) {
  auto fieldName__ = fieldName ? _fbb.CreateString(fieldName) : 0;
  return ChipVerif::CreateregisterInfo(
      _fbb,
      fieldName__,
      address,
      value,
      fixedPoint);
}

struct chipTestConfig FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef chipTestConfigBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_CHIPFUNCTIONNAME = 4,
    VT_COMMONREGISTER = 6,
    VT_REGISTERS = 8,
    VT_INPUTTYPE = 10,
    VT_OUTPUTTYPE = 12,
    VT_INPUTSOURCES = 14,
    VT_OUTPUTSOURCES = 16
  };
  const ::flatbuffers::String *chipFunctionName() const {
    return GetPointer<const ::flatbuffers::String *>(VT_CHIPFUNCTIONNAME);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<ChipVerif::commonRegisterInfo>> *commonRegister() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<ChipVerif::commonRegisterInfo>> *>(VT_COMMONREGISTER);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<ChipVerif::registerInfo>> *registers() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<ChipVerif::registerInfo>> *>(VT_REGISTERS);
  }
  uint32_t inputType() const {
    return GetField<uint32_t>(VT_INPUTTYPE, 0);
  }
  uint32_t outputType() const {
    return GetField<uint32_t>(VT_OUTPUTTYPE, 0);
  }
  const ::flatbuffers::Vector<uint8_t> *inputSources() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_INPUTSOURCES);
  }
  const ::flatbuffers::Vector<uint8_t> *outputSources() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_OUTPUTSOURCES);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_CHIPFUNCTIONNAME) &&
           verifier.VerifyString(chipFunctionName()) &&
           VerifyOffset(verifier, VT_COMMONREGISTER) &&
           verifier.VerifyVector(commonRegister()) &&
           verifier.VerifyVectorOfTables(commonRegister()) &&
           VerifyOffset(verifier, VT_REGISTERS) &&
           verifier.VerifyVector(registers()) &&
           verifier.VerifyVectorOfTables(registers()) &&
           VerifyField<uint32_t>(verifier, VT_INPUTTYPE, 4) &&
           VerifyField<uint32_t>(verifier, VT_OUTPUTTYPE, 4) &&
           VerifyOffset(verifier, VT_INPUTSOURCES) &&
           verifier.VerifyVector(inputSources()) &&
           VerifyOffset(verifier, VT_OUTPUTSOURCES) &&
           verifier.VerifyVector(outputSources()) &&
           verifier.EndTable();
  }
};

struct chipTestConfigBuilder {
  typedef chipTestConfig Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_chipFunctionName(::flatbuffers::Offset<::flatbuffers::String> chipFunctionName) {
    fbb_.AddOffset(chipTestConfig::VT_CHIPFUNCTIONNAME, chipFunctionName);
  }
  void add_commonRegister(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<ChipVerif::commonRegisterInfo>>> commonRegister) {
    fbb_.AddOffset(chipTestConfig::VT_COMMONREGISTER, commonRegister);
  }
  void add_registers(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<ChipVerif::registerInfo>>> registers) {
    fbb_.AddOffset(chipTestConfig::VT_REGISTERS, registers);
  }
  void add_inputType(uint32_t inputType) {
    fbb_.AddElement<uint32_t>(chipTestConfig::VT_INPUTTYPE, inputType, 0);
  }
  void add_outputType(uint32_t outputType) {
    fbb_.AddElement<uint32_t>(chipTestConfig::VT_OUTPUTTYPE, outputType, 0);
  }
  void add_inputSources(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> inputSources) {
    fbb_.AddOffset(chipTestConfig::VT_INPUTSOURCES, inputSources);
  }
  void add_outputSources(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> outputSources) {
    fbb_.AddOffset(chipTestConfig::VT_OUTPUTSOURCES, outputSources);
  }
  explicit chipTestConfigBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<chipTestConfig> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<chipTestConfig>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<chipTestConfig> CreatechipTestConfig(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> chipFunctionName = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<ChipVerif::commonRegisterInfo>>> commonRegister = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<ChipVerif::registerInfo>>> registers = 0,
    uint32_t inputType = 0,
    uint32_t outputType = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> inputSources = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> outputSources = 0) {
  chipTestConfigBuilder builder_(_fbb);
  builder_.add_outputSources(outputSources);
  builder_.add_inputSources(inputSources);
  builder_.add_outputType(outputType);
  builder_.add_inputType(inputType);
  builder_.add_registers(registers);
  builder_.add_commonRegister(commonRegister);
  builder_.add_chipFunctionName(chipFunctionName);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<chipTestConfig> CreatechipTestConfigDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *chipFunctionName = nullptr,
    const std::vector<::flatbuffers::Offset<ChipVerif::commonRegisterInfo>> *commonRegister = nullptr,
    const std::vector<::flatbuffers::Offset<ChipVerif::registerInfo>> *registers = nullptr,
    uint32_t inputType = 0,
    uint32_t outputType = 0,
    const std::vector<uint8_t> *inputSources = nullptr,
    const std::vector<uint8_t> *outputSources = nullptr) {
  auto chipFunctionName__ = chipFunctionName ? _fbb.CreateString(chipFunctionName) : 0;
  auto commonRegister__ = commonRegister ? _fbb.CreateVector<::flatbuffers::Offset<ChipVerif::commonRegisterInfo>>(*commonRegister) : 0;
  auto registers__ = registers ? _fbb.CreateVector<::flatbuffers::Offset<ChipVerif::registerInfo>>(*registers) : 0;
  auto inputSources__ = inputSources ? _fbb.CreateVector<uint8_t>(*inputSources) : 0;
  auto outputSources__ = outputSources ? _fbb.CreateVector<uint8_t>(*outputSources) : 0;
  return ChipVerif::CreatechipTestConfig(
      _fbb,
      chipFunctionName__,
      commonRegister__,
      registers__,
      inputType,
      outputType,
      inputSources__,
      outputSources__);
}

inline const ChipVerif::chipTestConfig *GetchipTestConfig(const void *buf) {
  return ::flatbuffers::GetRoot<ChipVerif::chipTestConfig>(buf);
}

inline const ChipVerif::chipTestConfig *GetSizePrefixedchipTestConfig(const void *buf) {
  return ::flatbuffers::GetSizePrefixedRoot<ChipVerif::chipTestConfig>(buf);
}

inline bool VerifychipTestConfigBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<ChipVerif::chipTestConfig>(nullptr);
}

inline bool VerifySizePrefixedchipTestConfigBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<ChipVerif::chipTestConfig>(nullptr);
}

inline void FinishchipTestConfigBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<ChipVerif::chipTestConfig> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedchipTestConfigBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<ChipVerif::chipTestConfig> root) {
  fbb.FinishSizePrefixed(root);
}

}  // namespace ChipVerif

#endif  // FLATBUFFERS_GENERATED_CONFIG_CHIPVERIF_H_
